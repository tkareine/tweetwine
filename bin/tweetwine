#!/usr/bin/env ruby

require "rubygems"
require "getoptlong"
require "yaml"
require File.dirname(__FILE__) << "/../lib/tweetwine"

include Tweetwine

class HelpNeeded < RuntimeError; end

def exit_with_error(why = nil)
  puts "#{why}" if why
  exit(2)
end

def exit_with_usage(why = nil)
  puts "#{why}\n\n" if why
  puts <<-END
Usage: tweetwine [-a username:password] [-c] [command]

  The program needs the user's username and password for authentication.
  This information can be given either as an option to the program or via a
  configuration file. Without option [-a], the program attempts to read the
  configuration file in YAML format at "~/.tweetwine" for authentication.

  Argument [command] can be one of #{Client::COMMANDS.map {|cmd| "\"#{cmd}\"" }.join(",")}.
  If [command] is not given, it defaults to "friend".

  Options:

  -a, --auth username:password      Authentication data.
  -c, --color                       Colorize output with ANSI escape codes.
  -h, --help                        This help message.

  END
  exit(1)
end

def parse_args
  options = {
    :colorize => false
  }

  opts = GetoptLong.new(
    [ "--auth", "-a", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--color", "-c", GetoptLong::NO_ARGUMENT ],
    [ "--help", "-h", GetoptLong::NO_ARGUMENT ]
  )

  opts.each do |opt, arg|
    case opt
    when "--auth" then options[:username], options[:password] = arg.split(":", 2)
    when "--color" then options[:colorize] = true
    when "--help" then raise HelpNeeded
    end
  end rescue exit_with_usage

  unless options[:username]
    begin
      config = YAML.load(File.read(ENV["HOME"] + "/.tweetwine"))
      options[:username], options[:password] = [config["username"], config["password"]]
      options[:colorize] = config["colorize"] if config.has_key? "colorize"
    rescue
      raise ArgumentError, "No auth info given as argument and no configuration file (~/.tweetwine) found."
    end
  end

  command = if ARGV.empty? then "friends" else ARGV.shift end
  raise ArgumentError, "Unknown command." unless Client::COMMANDS.include? command

  [command, options]
end

begin
  command, options = parse_args
  client = Client.new(options)
  client.send(command.to_sym)
rescue HelpNeeded
  exit_with_usage
rescue ArgumentError => e
  exit_with_usage e.message
rescue RuntimeError => e
  exit_with_error e.message
end
